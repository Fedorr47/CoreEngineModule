diff --git a/src/Render/DirectX12/RHIImpl/DirectX12RHI_Device.inl b/src/Render/DirectX12/RHIImpl/DirectX12RHI_Device.inl
index b4c0a9a..d6c7c44 100644
--- a/src/Render/DirectX12/RHIImpl/DirectX12RHI_Device.inl
+++ b/src/Render/DirectX12/RHIImpl/DirectX12RHI_Device.inl
@@ -1,3 +1,45 @@
+// NOTE:
+// Pipeline State Stream parsing requires each subobject to be aligned to sizeof(void*)
+// and for the stream layout to be well-formed. A common source of E_INVALIDARG is a
+// custom subobject wrapper that doesn't add trailing padding so the next subobject's
+// Type field starts at a pointer-aligned offset.
+
+template <D3D12_PIPELINE_STATE_SUBOBJECT_TYPE Type, typename T>
+struct alignas(void*) PSOSubobject
+{
+    static constexpr std::size_t kAlign = sizeof(void*);
+    static constexpr std::size_t kBaseSize = sizeof(D3D12_PIPELINE_STATE_SUBOBJECT_TYPE) + sizeof(T);
+    static constexpr std::size_t kPaddedSize = ((kBaseSize + (kAlign - 1)) / kAlign) * kAlign;
+    static constexpr std::size_t kPadSize = kPaddedSize - kBaseSize;
+
+    D3D12_PIPELINE_STATE_SUBOBJECT_TYPE type{ Type };
+    T data{};
+    std::array<std::uint8_t, kPadSize> _pad{};
+};
+
@@ -1156,6 +1198,22 @@

                         using SO_RootSig   = PSOSubobject<D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_ROOT_SIGNATURE, ID3D12RootSignature*>;
                         using SO_VS        = PSOSubobject<D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_VS, D3D12_SHADER_BYTECODE>;
                         using SO_PS        = PSOSubobject<D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_PS, D3D12_SHADER_BYTECODE>;
@@ -1166,6 +1224,18 @@
                         using SO_SampleDesc = PSOSubobject<D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_SAMPLE_DESC, DXGI_SAMPLE_DESC>;
                         using SO_ViewInst = PSOSubobject<D3D12_PIPELINE_STATE_SUBOBJECT_TYPE_VIEW_INSTANCING, D3D12_VIEW_INSTANCING_DESC>;
+
+                        // Each stream subobject must be pointer-aligned, and its size should be a multiple of sizeof(void*)
+                        // so the next Type is correctly aligned in the byte stream.
+                        static_assert(sizeof(SO_RootSig)   % sizeof(void*) == 0);
+                        static_assert(sizeof(SO_VS)        % sizeof(void*) == 0);
+                        static_assert(sizeof(SO_PS)        % sizeof(void*) == 0);
+                        static_assert(sizeof(SO_Blend)     % sizeof(void*) == 0);
+                        static_assert(sizeof(SO_SampleMask)% sizeof(void*) == 0);
+                        static_assert(sizeof(SO_Raster)    % sizeof(void*) == 0);
+                        static_assert(sizeof(SO_Depth)     % sizeof(void*) == 0);
+                        static_assert(sizeof(SO_Input)     % sizeof(void*) == 0);
+                        static_assert(sizeof(SO_Topo)      % sizeof(void*) == 0);
+                        static_assert(sizeof(SO_RTVFmts)   % sizeof(void*) == 0);
+                        static_assert(sizeof(SO_DSVFmt)    % sizeof(void*) == 0);
+                        static_assert(sizeof(SO_SampleDesc)% sizeof(void*) == 0);
+                        static_assert(sizeof(SO_ViewInst)  % sizeof(void*) == 0);
