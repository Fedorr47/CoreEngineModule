From 59fdb6edc802cc5f2b1b85b4b3afca7433217934 Mon Sep 17 00:00:00 2001
From: patchbot <patchbot@example.com>
Date: Tue, 17 Feb 2026 17:19:02 +0000
Subject: [PATCH] renderer: point shadow VI pass + fallback + disable cache

---
 src/Render/DirectX12/DirectX12Renderer.cppm   |   1 +
 ...rer_CreateResources_02_ShadowPipelines.inl |  62 +++++----
 ...12Renderer_RenderFrame_02_ShadowPasses.inl | 128 ++++++++++++++----
 3 files changed, 143 insertions(+), 48 deletions(-)

diff --git a/src/Render/DirectX12/DirectX12Renderer.cppm b/src/Render/DirectX12/DirectX12Renderer.cppm
index 2542674..9580b05 100644
--- a/src/Render/DirectX12/DirectX12Renderer.cppm
+++ b/src/Render/DirectX12/DirectX12Renderer.cppm
@@ -400,6 +400,7 @@ export namespace rendern
 		// Point shadow pass (R32_FLOAT distance cubemap)
 		rhi::PipelineHandle psoPointShadow_{};
 		rhi::PipelineHandle psoPointShadowVI_{}; // SM6.1 + SV_ViewID + view instancing (single-pass cubemap)
+		bool disablePointShadowVI_{ false };// do not try again after first failure (until restart)
 		rhi::GraphicsState pointShadowState_{};
 
 		MeshRHI skyboxMesh_{};
diff --git a/src/Render/DirectX12/RendererImpl/DirectX12Renderer_CreateResources_02_ShadowPipelines.inl b/src/Render/DirectX12/RendererImpl/DirectX12Renderer_CreateResources_02_ShadowPipelines.inl
index 079c4b4..9647f8c 100644
--- a/src/Render/DirectX12/RendererImpl/DirectX12Renderer_CreateResources_02_ShadowPipelines.inl
+++ b/src/Render/DirectX12/RendererImpl/DirectX12Renderer_CreateResources_02_ShadowPipelines.inl
@@ -47,31 +47,47 @@
 				psoPointShadow_ = psoCache_.GetOrCreate("PSO_PointShadow", vsPoint, psPoint);
 
 				// Optional View-Instancing variant (single pass renders all 6 cubemap faces).
-				// Requires SM6.1 + DXC + ViewInstancingTier support.
-				if (device_.SupportsShaderModel6() && device_.SupportsViewInstancing())
-				{
-					const auto vsPointVI = shaderLibrary_.GetOrCreateShader(ShaderKey{
-						.stage = rhi::ShaderStage::Vertex,
-						.shaderModel = rhi::ShaderModel::SM6_1,
-						.name = "VS_ShadowPointVI",
-						.filePath = pointShadowVIPath.string(),
-						.defines = {}
-						});
-					const auto psPointVI = shaderLibrary_.GetOrCreateShader(ShaderKey{
-						.stage = rhi::ShaderStage::Pixel,
-						.shaderModel = rhi::ShaderModel::SM6_1,
-						.name = "PS_ShadowPointVI",
-						.filePath = pointShadowVIPath.string(),
-						.defines = {}
-						});
+// Requires SM6.1 + DXC + ViewInstancingTier support.
+//
+// Safety: if it fails once (DXC missing/compile error/PSO creation failure), we disable further attempts
+// until restart to avoid repeated DXC/PSO work.
+if (!disablePointShadowVI_)
+{
+	if (device_.SupportsShaderModel6() && device_.SupportsViewInstancing())
+	{
+		const auto vsPointVI = shaderLibrary_.GetOrCreateShader(ShaderKey{
+			.stage = rhi::ShaderStage::Vertex,
+			.shaderModel = rhi::ShaderModel::SM6_1,
+			.name = "VS_ShadowPointVI",
+			.filePath = pointShadowVIPath.string(),
+			.defines = {}
+			});
+		const auto psPointVI = shaderLibrary_.GetOrCreateShader(ShaderKey{
+			.stage = rhi::ShaderStage::Pixel,
+			.shaderModel = rhi::ShaderModel::SM6_1,
+			.name = "PS_ShadowPointVI",
+			.filePath = pointShadowVIPath.string(),
+			.defines = {}
+			});
 
-					if (vsPointVI && psPointVI)
-					{
-						psoPointShadowVI_ = psoCache_.GetOrCreate("PSO_PointShadow_VI", vsPointVI, psPointVI, rhi::PrimitiveTopologyType::Triangle, 6);
-					}
-				}
+		if (vsPointVI && psPointVI)
+		{
+			psoPointShadowVI_ = psoCache_.GetOrCreate("PSO_PointShadow_VI", vsPointVI, psPointVI, rhi::PrimitiveTopologyType::Triangle, 6);
+		}
+	}
+	else
+	{
+		// Not supported on this device; avoid checking again.
+		disablePointShadowVI_ = true;
+	}
 
-				pointShadowState_.depth.testEnable = true;
+	if (!psoPointShadowVI_)
+	{
+		// Failed to create (DXC/compile/PSO), stick to the 6-pass fallback for this run.
+		disablePointShadowVI_ = true;
+	}
+}
+pointShadowState_.depth.testEnable = true;
 				pointShadowState_.depth.writeEnable = true;
 				pointShadowState_.depth.depthCompareOp = rhi::CompareOp::LessEqual;
 
diff --git a/src/Render/DirectX12/RendererImpl/DirectX12Renderer_RenderFrame_02_ShadowPasses.inl b/src/Render/DirectX12/RendererImpl/DirectX12Renderer_RenderFrame_02_ShadowPasses.inl
index 19aae55..52841e3 100644
--- a/src/Render/DirectX12/RendererImpl/DirectX12Renderer_RenderFrame_02_ShadowPasses.inl
+++ b/src/Render/DirectX12/RendererImpl/DirectX12Renderer_RenderFrame_02_ShadowPasses.inl
@@ -124,7 +124,11 @@
 				}
 				else if (light.type == LightType::Point && pointShadows.size() < kMaxPointShadows)
 				{
-					// Point shadows use a cubemap R32_FLOAT distance map (color) + a temporary D32 depth buffer.
+					// Point shadows use a cubemap R32_FLOAT distance map (color) + depth for rasterization.
+					// If VI pipeline is available, we render all 6 faces in a single pass (SV_ViewID + view instancing).
+					// Otherwise we fall back to 6 separate passes (face-by-face).
+					const bool useVI = (!disablePointShadowVI_) && static_cast<bool>(psoPointShadowVI_);
+
 					const rhi::Extent2D cubeExtent{ 2048, 2048 };
 					const auto cube = graph.CreateTexture(renderGraph::RGTextureDesc{
 						.extent = cubeExtent,
@@ -134,16 +138,31 @@
 						.debugName = "PointShadowCube"
 						});
 
-					const auto depthTmp = graph.CreateTexture(renderGraph::RGTextureDesc{
-						.extent = cubeExtent,
-						.format = rhi::Format::D32_FLOAT,
-						.usage = renderGraph::ResourceUsage::DepthStencil,
-						.debugName = "PointShadowDepthTmp"
-						});
+					// Depth: for VI we need a cubemap depth array (all faces). For fallback a temporary 2D depth buffer is enough.
+					renderGraph::RGTextureHandle depth{};
+					if (useVI)
+					{
+						depth = graph.CreateTexture(renderGraph::RGTextureDesc{
+							.extent = cubeExtent,
+							.format = rhi::Format::D32_FLOAT,
+							.usage = renderGraph::ResourceUsage::DepthStencil,
+							.type = renderGraph::TextureType::Cube,
+							.debugName = "PointShadowDepthCube"
+							});
+					}
+					else
+					{
+						depth = graph.CreateTexture(renderGraph::RGTextureDesc{
+							.extent = cubeExtent,
+							.format = rhi::Format::D32_FLOAT,
+							.usage = renderGraph::ResourceUsage::DepthStencil,
+							.debugName = "PointShadowDepthTmp"
+							});
+					}
 
 					PointShadowRec rec{};
 					rec.cube = cube;
-					rec.depthTmp = depthTmp;
+					rec.depthTmp = depth;
 					rec.pos = light.position;
 					rec.range = std::max(1.0f, light.range);
 					rec.lightIndex = lightIndex;
@@ -164,42 +183,44 @@
 
 					const mathUtils::Mat4 proj90 = mathUtils::PerspectiveRH_ZO(mathUtils::DegToRad(90.0f), 1.0f, 0.1f, rec.range);
 
-					for (int face = 0; face < 6; ++face)
+					if (useVI)
 					{
-						const mathUtils::Mat4 faceViewProj = proj90 * FaceView(rec.pos, face);
-
+						// One pass: render all faces using SV_ViewID.
 						rhi::ClearDesc clear{};
 						clear.clearColor = true;
 						clear.clearDepth = true;
-
 						clear.color = { 1.0f, 1.0f, 1.0f, 1.0f }; // far
 						clear.depth = 1.0f;
 
 						renderGraph::PassAttachments att{};
 						att.useSwapChainBackbuffer = false;
 						att.color = cube;
-						att.colorCubeFace = static_cast<std::uint32_t>(face);
-						att.depth = depthTmp;
+						att.colorCubeAllFaces = true;
+						att.depth = depth;
 						att.clearDesc = clear;
 
 						const std::string passName =
-							"PointShadowPass_" + std::to_string(static_cast<int>(pointShadows.size() - 1)) +
-							"_F" + std::to_string(face);
+							"PointShadowPassVI_" + std::to_string(static_cast<int>(pointShadows.size() - 1));
 
-						struct alignas(16) PointShadowConstants
+						struct alignas(16) PointShadowVIConstants
 						{
-							std::array<float, 16> uFaceViewProj{};
-							std::array<float, 4>  uLightPosRange{}; // xyz + range
-							std::array<float, 4>  uMisc{};          // unused (bias is texel-based in main shader)
+							// 6 matrices as ROWS (transposed on CPU).
+							std::array<float, 16 * 6> uFaceViewProj{};
+							std::array<float, 4>      uLightPosRange{}; // xyz + range
+							std::array<float, 4>      uMisc{};          // unused (bias is texel-based in main shader)
 						};
 
-						PointShadowConstants pointShadowConstants{};
-						const mathUtils::Mat4 faceViewProjTranspose = mathUtils::Transpose(faceViewProj);
-						std::memcpy(pointShadowConstants.uFaceViewProj.data(), mathUtils::ValuePtr(faceViewProjTranspose), sizeof(float) * 16);
+						PointShadowVIConstants pointShadowConstants{};
+						for (int face = 0; face < 6; ++face)
+						{
+							const mathUtils::Mat4 faceViewProj = proj90 * FaceView(rec.pos, face);
+							const mathUtils::Mat4 faceViewProjTranspose = mathUtils::Transpose(faceViewProj);
+							std::memcpy(pointShadowConstants.uFaceViewProj.data() + (face * 16),
+								mathUtils::ValuePtr(faceViewProjTranspose), sizeof(float) * 16);
+						}
 						pointShadowConstants.uLightPosRange = { rec.pos.x, rec.pos.y, rec.pos.z, rec.range };
 						pointShadowConstants.uMisc = { 0, 0, 0, 0 };
 
-
 						graph.AddPass(passName, std::move(att),
 							[this, pointShadowConstants, shadowBatches, instStride](renderGraph::PassContext& ctx) mutable
 							{
@@ -208,7 +229,7 @@
 									static_cast<int>(ctx.passExtent.height));
 
 								ctx.commandList.SetState(pointShadowState_);
-								ctx.commandList.BindPipeline(psoPointShadow_);
+								ctx.commandList.BindPipeline(psoPointShadowVI_);
 
 								ctx.commandList.SetConstants(0, std::as_bytes(std::span{ &pointShadowConstants, 1 }));
 
@@ -216,7 +237,64 @@
 
 							});
 					}
+					else
+					{
+						// Fallback: 6 passes (one cubemap face per pass).
+						for (int face = 0; face < 6; ++face)
+						{
+							const mathUtils::Mat4 faceViewProj = proj90 * FaceView(rec.pos, face);
+
+							rhi::ClearDesc clear{};
+							clear.clearColor = true;
+							clear.clearDepth = true;
+
+							clear.color = { 1.0f, 1.0f, 1.0f, 1.0f }; // far
+							clear.depth = 1.0f;
+
+							renderGraph::PassAttachments att{};
+							att.useSwapChainBackbuffer = false;
+							att.color = cube;
+							att.colorCubeFace = static_cast<std::uint32_t>(face);
+							att.depth = depth;
+							att.clearDesc = clear;
+
+							const std::string passName =
+								"PointShadowPass_" + std::to_string(static_cast<int>(pointShadows.size() - 1)) +
+								"_F" + std::to_string(face);
+
+							struct alignas(16) PointShadowConstants
+							{
+								std::array<float, 16> uFaceViewProj{};
+								std::array<float, 4>  uLightPosRange{}; // xyz + range
+								std::array<float, 4>  uMisc{};          // unused (bias is texel-based in main shader)
+							};
+
+							PointShadowConstants pointShadowConstants{};
+							const mathUtils::Mat4 faceViewProjTranspose = mathUtils::Transpose(faceViewProj);
+							std::memcpy(pointShadowConstants.uFaceViewProj.data(), mathUtils::ValuePtr(faceViewProjTranspose), sizeof(float) * 16);
+							pointShadowConstants.uLightPosRange = { rec.pos.x, rec.pos.y, rec.pos.z, rec.range };
+							pointShadowConstants.uMisc = { 0, 0, 0, 0 };
+
+
+							graph.AddPass(passName, std::move(att),
+								[this, pointShadowConstants, shadowBatches, instStride](renderGraph::PassContext& ctx) mutable
+								{
+									ctx.commandList.SetViewport(0, 0,
+										static_cast<int>(ctx.passExtent.width),
+										static_cast<int>(ctx.passExtent.height));
+
+									ctx.commandList.SetState(pointShadowState_);
+									ctx.commandList.BindPipeline(psoPointShadow_);
+
+									ctx.commandList.SetConstants(0, std::as_bytes(std::span{ &pointShadowConstants, 1 }));
+
+									this->DrawInstancedShadowBatches(ctx.commandList, shadowBatches, instStride);
+
+								});
+						}
+					}
 				}
+
 			}
 
 			// Upload shadow metadata (t11).
-- 
2.39.5

